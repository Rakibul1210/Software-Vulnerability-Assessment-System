import torch
import transformers

# Define the model names
model_names = ['attackVector', 'attackComplexity', 'privilegesRequired',
               'userInteraction', 'scope', 'confidentialityImpact',
               'integrityImpact', 'availabilityImpact']

# Load the BERT models and tokenizers
models = {}
tokenizers = {}
for name in model_names:
    model_path = f"{name}_model.bin"  # Replace with actual file paths
    tokenizer_path = f"{name}_tokenizer.bin"  # Replace with actual file paths
    model = transformers.BertForSequenceClassification.from_pretrained(model_path)
    tokenizer = transformers.BertTokenizer.from_pretrained(tokenizer_path)
    models[name] = model
    tokenizers[name] = tokenizer


# Define the predict_base_metrics function
def predict_base_metrics(description):
    # Create an empty dictionary to store the predicted values for each model
    results = {}

    # Process the description using each tokenizer
    input_ids = {}
    attention_masks = {}
    for name, tokenizer in tokenizers.items():
        inputs = tokenizer(description, return_tensors='pt')
        input_ids[name] = inputs['input_ids']
        attention_masks[name] = inputs['attention_mask']

    # Make predictions using each model
    for name, model in models.items():
        input_ids_tensor = input_ids[name].to(model.device)
        attention_masks_tensor = attention_masks[name].to(model.device)
        outputs = model(input_ids_tensor, attention_mask=attention_masks_tensor)
        logits = outputs[0]
        prediction = torch.argmax(logits, dim=1).tolist()[0]
        results[name] = prediction

    # Return the predicted values for all models
    return results


if __name__ == 'main':
    print("Hello World")
    # description = "Receipt of a malformed packet on MX Series devices with dynamic vlan configuration can trigger an " \
    #               "uncontrolled recursion loop in the Broadband Edge subscriber management daemon (bbe-smgd), " \
    #               "and lead to high CPU usage and a crash of the bbe-smgd service. Repeated receipt of the same " \
    #               "packet can result in an extended denial of service condition for the device. Affected releases are " \
    #               "Juniper Networks Junos OS: 16.1 versions prior to 16.1R7-S1; 16.2 versions prior to 16.2R2-S7; " \
    #               "17.1 versions prior to 17.1R2-S10, 17.1R3; 17.2 versions prior to 17.2R3; 17.3 versions prior to " \
    #               "17.3R3-S1; 17.4 versions prior to 17.4R2; 18.1 versions prior to 18.1R3; 18.2 versions prior to " \
    #               "18.2R2."
    #
    # baseMetrics = []
    #
    #
    # models = ['AttackVector', 'AttackComplexity', 'PrivilegesRequired', 'UserInteraction',
    #           'Scope', 'ConfidentialityImpact', 'IntegrityImpact', 'AvailabilityImpact']
    #
    # labels = [
    #     ['PHYSICAL', 'LOCAL', 'NETWORK', 'ADJACENT'],
    #     ['LOW', 'HIGH'],
    #     ['NONE', 'LOW', 'HIGH'],
    #     ['NONE', 'REQUIRED'],
    #     ['UNCHANGED', 'CHANGED'],
    #     ['NONE', 'LOW', 'HIGH'],
    #     ['NONE', 'LOW', 'HIGH'],
    #     ['NONE', 'LOW', 'HIGH']
    # ]
    # for model_path, label in zip(models, labels):
    #     path = 'Saved_Models/' + model_path
    #     predictor = Predictor(path, label)
    #     baseMetrics.append(predictor.predict_bert_metrices(description))
    #
    # print(baseMetrics)
    #
    # base_metrices = predict_base_metrics(description)
    #
    # print(base_metrices)
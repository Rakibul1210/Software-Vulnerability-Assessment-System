import torch
from transformers import BertTokenizer
from transformers import AutoModelForSequenceClassification
from sklearn import preprocessing
from cvss_calculator import CVSSCalculator


class Predictor:
    def __init__(self, model_path, labels):
        self.tokenizer = BertTokenizer.from_pretrained(model_path, do_lower_case=True)
        self.model = AutoModelForSequenceClassification.from_pretrained(model_path)
        self.device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        self.encoder = preprocessing.LabelEncoder()
        self.encoder.fit(list(labels))
        self.model.to(self.device)

    def predict_bert_metrices(self, description):
        X_test = description
        lent = len(X_test)
        X_test = self.tokenizer(X_test, return_tensors="pt", padding="max_length", max_length=128, truncation=True)

        test_ids = []
        test_attention_mask = []

        test_ids.append(X_test['input_ids'])
        test_attention_mask.append(X_test['attention_mask'])
        test_ids = torch.cat(test_ids, dim=0)
        test_attention_mask = torch.cat(test_attention_mask, dim=0)

        self.model.eval()
        self.model.to("cpu")
        with torch.no_grad():
            predictions = self.model(test_ids.to("cpu"), token_type_ids=None,
                                     attention_mask=test_attention_mask.to("cpu"))

        predictions_class = []
        for i in range(lent):
            predictions_class.append(predictions.logits.softmax(1)[i].argmax().item())

        predictions_class = self.encoder.inverse_transform(predictions_class)

        return predictions_class[0]

# models = ['AttackVector', 'AttackComplexity', 'PrivilegesRequired', 'UserInteraction',
#           'Scope', 'ConfidentialityImpact', 'IntegrityImpact', 'AvailabilityImpact']
#
# descriptions = []
#
# labels = [
#             ['PHYSICAL', 'LOCAL', 'NETWORK', 'ADJACENT'],
#             ['LOW', 'HIGH'],
#             ['NONE', 'LOW', 'HIGH'],
#             ['NONE', 'REQUIRED'],
#             ['UNCHANGED', 'CHANGED'],
#             ['NONE', 'LOW', 'HIGH'],
#             ['NONE', 'LOW', 'HIGH'],
#             ['NONE', 'LOW', 'HIGH']
#           ]
#
# baseMetrics = []
#
# for model_path, label in zip(models, labels):
#     path= 'Saved_Models/'+model_path
#     predictor = Predictor(path, label)
#     baseMetrics.append(predictor.predict_bert_metrices(descriptions))
# print(baseMetrics)
